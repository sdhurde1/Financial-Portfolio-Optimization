# -*- coding: utf-8 -*-
"""Financial Portfolio Optimization.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1k6-C3j2ICV7LO08xdsXALB5LHSMjvHzs
"""

pip install numpy scipy matplotlib pandas yfinance

import yfinance as yf
import pandas as pd

# Define stock tickers
tickers = ['AAPL', 'MSFT', 'TSLA']

# Download historical data (5 years of data)
stock_data = yf.download(tickers, start='2018-01-01', end='2023-01-01')['Adj Close']

# Display the first few rows
print(stock_data.head())

# Calculate daily returns
daily_returns = stock_data.pct_change().dropna()

# Display the first few rows
print(daily_returns.head())

# Calculate expected returns (mean of daily returns * 252 for annual returns)
expected_returns = daily_returns.mean() * 252

# Calculate the covariance matrix (daily covariance * 252 for annual covariance)
cov_matrix = daily_returns.cov() * 252

print("Expected Annual Returns:\n", expected_returns)
print("\nCovariance Matrix:\n", cov_matrix)

import numpy as np
from scipy.optimize import minimize

# Function to calculate portfolio performance
def portfolio_performance(weights, mean_returns, cov_matrix):
    portfolio_return = np.sum(mean_returns * weights)
    portfolio_volatility = np.sqrt(np.dot(weights.T, np.dot(cov_matrix, weights)))
    return portfolio_return, portfolio_volatility

# Function to minimize (negative Sharpe Ratio)
def minimize_volatility(weights, mean_returns, cov_matrix):
    return portfolio_performance(weights, mean_returns, cov_matrix)[1]

# Number of assets in portfolio
num_assets = len(tickers)

# Randomly initialize weights
initial_weights = np.random.random(num_assets)
initial_weights /= np.sum(initial_weights)  # Normalize the weights

# Constraints (weights sum to 1)
constraints = ({'type': 'eq', 'fun': lambda x: np.sum(x) - 1})

# Bounds for each weight (between 0 and 1)
bounds = tuple((0, 1) for asset in range(num_assets))

# Optimize portfolio weights
result = minimize(minimize_volatility, initial_weights, args=(expected_returns, cov_matrix),
                  method='SLSQP', bounds=bounds, constraints=constraints)

# Display optimized weights and performance
optimal_weights = result.x
portfolio_return, portfolio_volatility = portfolio_performance(optimal_weights, expected_returns, cov_matrix)

print("Optimal Weights: ", optimal_weights)
print("Portfolio Return: ", portfolio_return)
print("Portfolio Volatility: ", portfolio_volatility)

import matplotlib.pyplot as plt

# Function to generate random portfolios
def generate_portfolios(num_portfolios, mean_returns, cov_matrix):
    results = np.zeros((3, num_portfolios))
    for i in range(num_portfolios):
        weights = np.random.random(num_assets)
        weights /= np.sum(weights)

        portfolio_return, portfolio_volatility = portfolio_performance(weights, mean_returns, cov_matrix)
        results[0,i] = portfolio_return
        results[1,i] = portfolio_volatility
        results[2,i] = portfolio_return / portfolio_volatility  # Sharpe ratio
    return results

# Generate portfolios
num_portfolios = 10000
results = generate_portfolios(num_portfolios, expected_returns, cov_matrix)

# Plot Efficient Frontier
plt.scatter(results[1,:], results[0,:], c=results[2,:], cmap='YlGnBu', marker='o')
plt.title('Efficient Frontier')
plt.xlabel('Volatility (Risk)')
plt.ylabel('Return')
plt.colorbar(label='Sharpe Ratio')
plt.show()